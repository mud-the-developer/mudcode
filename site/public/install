#!/usr/bin/env bash
set -euo pipefail

APP="mudcode"
OWNER="mudramo"
REPO="mudcode"
INSTALL_DIR="$HOME/.mudcode/bin"
NO_MODIFY_PATH=false

while [[ $# -gt 0 ]]; do
  case "$1" in
    --no-modify-path)
      NO_MODIFY_PATH=true
      shift
      ;;
    -h|--help)
      cat <<'EOF'
Mudcode installer

Usage:
  curl -fsSL https://mudcode.chat/install | bash
  curl -fsSL https://mudcode.chat/install | bash -s -- --no-modify-path
EOF
      exit 0
      ;;
    *)
      echo "Warning: Unknown option '$1' (ignored)" >&2
      shift
      ;;
  esac
done

mkdir -p "$INSTALL_DIR"

platform_raw=$(uname -s)
arch_raw=$(uname -m)

case "$platform_raw" in
  Darwin) platform="darwin" ;;
  Linux) platform="linux" ;;
  MINGW*|MSYS*|CYGWIN*) platform="windows" ;;
  *) echo "Unsupported platform: $platform_raw"; exit 1 ;;
esac

case "$arch_raw" in
  aarch64|arm64) arch="arm64" ;;
  x86_64|amd64) arch="x64" ;;
  *) echo "Unsupported architecture: $arch_raw"; exit 1 ;;
esac

suffix="$platform-$arch"

if [[ "$platform" == "linux" ]]; then
  if [[ -f /etc/alpine-release ]] || (command -v ldd >/dev/null 2>&1 && ldd --version 2>&1 | grep -qi musl); then
    suffix="$suffix-musl"
  fi
fi

if [[ "$arch" == "x64" ]]; then
  if [[ "$platform" == "linux" ]] && ! grep -qi avx2 /proc/cpuinfo 2>/dev/null; then
    suffix="$platform-$arch-baseline${suffix##*$arch}"
  fi
  if [[ "$platform" == "darwin" ]]; then
    avx2=$(sysctl -n hw.optional.avx2_0 2>/dev/null || echo 0)
    if [[ "$avx2" != "1" ]]; then
      suffix="$platform-$arch-baseline"
    fi
  fi
fi

archive_ext="zip"
if [[ "$platform" == "linux" ]]; then
  archive_ext="tar.gz"
fi

urlencode_path_segment() {
  local value="$1"
  value="${value//@/%40}"
  value="${value//\//%2f}"
  printf '%s' "$value"
}

json_extract_first_string() {
  local key="$1"
  sed -n "s/.*\"$key\"[[:space:]]*:[[:space:]]*\"\\([^\"]*\\)\".*/\\1/p" | head -n 1
}

npm_latest_version() {
  local meta_pkg
  meta_pkg="$(urlencode_path_segment "@$OWNER/$REPO")"
  curl -fsSL "https://registry.npmjs.org/$meta_pkg/latest" | json_extract_first_string "version"
}

npm_tarball_url() {
  local package_name="$1"
  local package_version="$2"
  local encoded_name
  encoded_name="$(urlencode_path_segment "$package_name")"
  curl -fsSL "https://registry.npmjs.org/$encoded_name/$package_version" | json_extract_first_string "tarball"
}

github_latest_version() {
  curl -fsSL "https://api.github.com/repos/$OWNER/$REPO/releases/latest" | sed -n 's/.*"tag_name": *"v\([^"]*\)".*/\1/p'
}

version="${VERSION:-}"
if [[ -z "$version" ]]; then
  version="$(npm_latest_version || true)"
fi

if [[ -z "$version" ]]; then
  version="$(github_latest_version || true)"
fi

if [[ -z "$version" ]]; then
  echo "Unable to determine release version from npm or GitHub."
  exit 1
fi

filename="$APP-$suffix.$archive_ext"
url="https://github.com/$OWNER/$REPO/releases/download/v$version/$filename"
package_name="@$OWNER/$APP-$suffix"

tmp_dir="${TMPDIR:-/tmp}/mudcode-install-$$"
mkdir -p "$tmp_dir"
trap 'rm -rf "$tmp_dir"' EXIT

binary=""
tarball_url="$(npm_tarball_url "$package_name" "$version" || true)"

if [[ -n "$tarball_url" ]]; then
  echo "Installing $APP v$version ($suffix) from npm package $package_name"
  curl -fL "$tarball_url" -o "$tmp_dir/package.tgz"
  tar -xzf "$tmp_dir/package.tgz" -C "$tmp_dir"
  binary="$tmp_dir/package/bin/$APP"
  if [[ "$platform" == "windows" && -f "$tmp_dir/package/bin/$APP.exe" ]]; then
    binary="$tmp_dir/package/bin/$APP.exe"
  fi
else
  echo "npm package $package_name@$version not available; falling back to GitHub releases"
  curl -fL "$url" -o "$tmp_dir/$filename"
  if [[ "$archive_ext" == "zip" ]]; then
    unzip -q "$tmp_dir/$filename" -d "$tmp_dir"
  else
    tar -xzf "$tmp_dir/$filename" -C "$tmp_dir"
  fi
  binary="$tmp_dir/$APP"
  if [[ "$platform" == "windows" ]]; then
    binary="$tmp_dir/$APP.exe"
  fi
fi

if [[ ! -f "$binary" ]]; then
  echo "Downloaded package did not contain $APP binary"
  exit 1
fi

cp "$binary" "$INSTALL_DIR/$APP"
chmod 755 "$INSTALL_DIR/$APP"

add_to_path() {
  local shell_name="$1"
  local command_line
  local config_file=""

  case "$shell_name" in
    fish) command_line="fish_add_path $INSTALL_DIR" ;;
    *) command_line="export PATH=\"$INSTALL_DIR:\$PATH\"" ;;
  esac

  local candidates=()
  case "$shell_name" in
    zsh)
      candidates=("${ZDOTDIR:-$HOME}/.zshrc" "${XDG_CONFIG_HOME:-$HOME/.config}/zsh/.zshrc")
      ;;
    bash)
      candidates=("$HOME/.bashrc" "$HOME/.bash_profile" "$HOME/.profile")
      ;;
    fish)
      candidates=("$HOME/.config/fish/config.fish")
      ;;
    *)
      candidates=("$HOME/.profile")
      ;;
  esac

  # Prefer an existing writable config file.
  for file in "${candidates[@]}"; do
    if [[ -f "$file" && -w "$file" ]]; then
      config_file="$file"
      break
    fi
  done

  # Fall back to creating the first candidate in home config.
  if [[ -z "$config_file" ]]; then
    config_file="${candidates[0]}"
    mkdir -p "$(dirname "$config_file")"
    touch "$config_file"
  fi

  if grep -Fq "$INSTALL_DIR" "$config_file"; then
    echo "PATH already configured in: $config_file"
    return
  fi

  {
    echo
    echo "# mudcode"
    echo "$command_line"
  } >> "$config_file"
  echo "Added PATH entry to: $config_file"
}

echo "Installed to: $INSTALL_DIR/$APP"

if [[ "$NO_MODIFY_PATH" == "true" ]]; then
  echo "Skipped PATH update (--no-modify-path)."
  echo "Add to PATH manually: export PATH=\"$INSTALL_DIR:\$PATH\""
else
  current_shell="$(basename "${SHELL:-sh}")"
  add_to_path "$current_shell"
fi

echo "Run now: export PATH=\"$INSTALL_DIR:\$PATH\""
