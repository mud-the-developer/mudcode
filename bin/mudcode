#!/usr/bin/env node

import childProcess from 'child_process';
import fs from 'fs';
import os from 'os';
import path from 'path';
import { fileURLToPath } from 'url';
import { createRequire } from 'module';

const require = createRequire(import.meta.url);
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const selfPackageName = readSelfPackageName();

function normalizeScope(raw) {
  const trimmed = (raw || '').trim();
  if (!trimmed) return '';
  return trimmed.startsWith('@') ? trimmed : `@${trimmed}`;
}

function readSelfPackageName() {
  const candidates = [
    path.join(__dirname, '..', 'package.json'),
    path.join(__dirname, '..', '..', 'package.json'),
  ];

  for (const candidate of candidates) {
    try {
      const parsed = JSON.parse(fs.readFileSync(candidate, 'utf-8'));
      if (typeof parsed?.name === 'string' && parsed.name.length > 0) {
        return parsed.name;
      }
    } catch {
      // continue
    }
  }

  return '';
}

function resolvePackageScope() {
  const envScope = normalizeScope(process.env.MUDCODE_NPM_SCOPE);
  if (envScope) return envScope;

  const packageName = readSelfPackageName();
  const match = packageName.match(/^(@[^/]+)\//);
  if (match) return match[1];

  return '@mudramo';
}

const packageScope = resolvePackageScope();

function spawnAndExit(command, args) {
  const result = childProcess.spawnSync(command, args, {
    stdio: 'inherit',
    env: {
      ...process.env,
      ...(selfPackageName ? { MUDCODE_NPM_PACKAGE: selfPackageName } : {}),
    },
  });
  if (result.error) {
    console.error(result.error.message);
    process.exit(1);
  }
  process.exit(typeof result.status === 'number' ? result.status : 0);
}

function spawnAndExitWithEnv(command, args, envPatch) {
  const result = childProcess.spawnSync(command, args, {
    stdio: 'inherit',
    env: {
      ...process.env,
      ...(selfPackageName ? { MUDCODE_NPM_PACKAGE: selfPackageName } : {}),
      ...envPatch,
    },
  });
  if (result.error) {
    console.error(result.error.message);
    process.exit(1);
  }
  process.exit(typeof result.status === 'number' ? result.status : 0);
}

function isMuslLinux() {
  if (os.platform() !== 'linux') return false;
  if (fs.existsSync('/etc/alpine-release')) return true;
  try {
    const out = childProcess.execSync('ldd --version 2>&1', { encoding: 'utf-8' });
    return out.toLowerCase().includes('musl');
  } catch {
    return false;
  }
}

function needsBaselineX64() {
  if (os.arch() !== 'x64') return false;
  if (os.platform() === 'linux') {
    try {
      const cpuinfo = fs.readFileSync('/proc/cpuinfo', 'utf-8').toLowerCase();
      return !cpuinfo.includes('avx2');
    } catch {
      return false;
    }
  }
  if (os.platform() === 'darwin') {
    try {
      const out = childProcess.execSync('sysctl -n hw.optional.avx2_0', { encoding: 'utf-8' }).trim();
      return out !== '1';
    } catch {
      return false;
    }
  }
  return false;
}

function findMissingSharedLibraries(binaryPath) {
  if (os.platform() !== 'linux') return [];

  const result = childProcess.spawnSync('ldd', [binaryPath], {
    encoding: 'utf-8',
  });
  if (result.error) return [];

  const output = `${result.stdout || ''}\n${result.stderr || ''}`;
  if (/not a dynamic executable|statically linked/i.test(output)) {
    return [];
  }

  const missing = [];
  for (const line of output.split('\n')) {
    if (!/=>\s*not found/.test(line)) continue;
    const match = line.match(/^\s*([^\s]+)\s+=>\s+not found/);
    if (match && match[1]) {
      missing.push(match[1]);
    }
  }
  return missing;
}

function packageCandidates() {
  const platformMap = {
    darwin: 'darwin',
    linux: 'linux',
    win32: 'windows',
  };
  const archMap = {
    x64: 'x64',
    arm64: 'arm64',
  };
  const platform = platformMap[os.platform()] || os.platform();
  const arch = archMap[os.arch()] || os.arch();
  const scopedBase = `${packageScope}/mudcode-${platform}-${arch}`;

  const candidates = [];

  if (platform === 'linux') {
    const useMuslFirst = isMuslLinux();
    const nativeCandidates = [];
    const muslCandidates = [];

    if (arch === 'x64' && needsBaselineX64()) {
      nativeCandidates.push(`${scopedBase}-baseline`);
      muslCandidates.push(`${scopedBase}-baseline-musl`);
    }

    nativeCandidates.push(scopedBase);
    muslCandidates.push(`${scopedBase}-musl`);

    if (useMuslFirst) {
      candidates.push(...muslCandidates, ...nativeCandidates);
    } else {
      candidates.push(...nativeCandidates, ...muslCandidates);
    }
    return candidates;
  }

  if (arch === 'x64' && needsBaselineX64()) {
    candidates.push(`${scopedBase}-baseline`);
  }
  candidates.push(scopedBase);
  return candidates;
}

function findPlatformBinary() {
  const binaryName = os.platform() === 'win32' ? 'mudcode.exe' : 'mudcode';
  for (const pkg of packageCandidates()) {
    try {
      const packageJsonPath = require.resolve(`${pkg}/package.json`);
      const packageDir = path.dirname(packageJsonPath);
      const binaryPath = path.join(packageDir, 'bin', binaryName);
      if (fs.existsSync(binaryPath)) {
        const missingLibs = findMissingSharedLibraries(binaryPath);
        if (missingLibs.length > 0) {
          console.warn(
            `[mudcode] Skipping ${pkg}: missing shared libraries (${missingLibs.join(', ')}). Trying next candidate...`,
          );
          continue;
        }
        return { binaryPath, packageDir };
      }
    } catch {
      // try next package candidate
    }
  }
  return null;
}

function resolveRustSidecarFromDir(dir) {
  const sidecarName = os.platform() === 'win32' ? 'mudcode-rs.exe' : 'mudcode-rs';
  const sidecarPath = path.join(dir, sidecarName);
  return fs.existsSync(sidecarPath) ? sidecarPath : null;
}

function findLocalDevEntrypoint() {
  const scriptDir = __dirname;
  const candidates = [
    path.join(scriptDir, '..', 'dist', 'bin', 'mudcode.js'),
    path.join(scriptDir, '..', 'dist', 'bin', 'mudcode.js'),
    path.join(scriptDir, '..', '..', 'dist', 'bin', 'mudcode.js'),
    path.join(scriptDir, '..', '..', 'dist', 'bin', 'mudcode.js'),
  ];
  return candidates.find((file) => fs.existsSync(file)) || null;
}

const explicitBinary = process.env.MUDCODE_BIN_PATH;
if (explicitBinary) {
  const rustSidecar = resolveRustSidecarFromDir(path.dirname(explicitBinary));
  if (rustSidecar && !process.env.MUDCODE_RS_BIN) {
    spawnAndExitWithEnv(explicitBinary, process.argv.slice(2), { MUDCODE_RS_BIN: rustSidecar });
  }
  spawnAndExit(explicitBinary, process.argv.slice(2));
}

const platformBinary = findPlatformBinary();
if (platformBinary) {
  const rustSidecar = resolveRustSidecarFromDir(path.join(platformBinary.packageDir, 'bin'));
  if (rustSidecar && !process.env.MUDCODE_RS_BIN) {
    spawnAndExitWithEnv(platformBinary.binaryPath, process.argv.slice(2), { MUDCODE_RS_BIN: rustSidecar });
  }
  spawnAndExit(platformBinary.binaryPath, process.argv.slice(2));
}

const devEntrypoint = findLocalDevEntrypoint();
if (devEntrypoint) {
  spawnAndExit(process.execPath, [devEntrypoint, ...process.argv.slice(2)]);
}

const packageName = readSelfPackageName() || `${packageScope}/mudcode`;
console.error('No runnable mudcode binary found for this platform.');
console.error(`Try reinstalling with: bun add -g ${packageName}`);
process.exit(1);
